% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mutate-helper.R
\name{more_than}
\alias{more_than}
\alias{less_than}
\alias{emerged}
\alias{vanished}
\alias{paired}
\alias{top}
\title{Get more_than, less_than, emerged, vanished, paired or top entities from a data frame.}
\usage{
more_than(
  df = ".",
  group_by,
  idents,
  id,
  subset = NULL,
  split_by = NULL,
  compare = ".n",
  return_type = c("uids", "ids", "subdf", "df", "interdf"),
  order = "desc(sum)",
  include_zeros = FALSE
)

less_than(
  df = ".",
  group_by,
  idents,
  id,
  subset = NULL,
  split_by = NULL,
  compare = ".n",
  return_type = c("uids", "ids", "subdf", "df", "interdf"),
  order = "desc(sum)",
  include_zeros = FALSE
)

emerged(
  df = ".",
  group_by,
  idents,
  id,
  subset = NULL,
  split_by = NULL,
  compare = ".n",
  return_type = c("uids", "ids", "subdf", "df", "interdf"),
  order = "desc(sum)",
  include_zeros = FALSE
)

vanished(
  df = ".",
  group_by,
  idents,
  id,
  subset = NULL,
  split_by = NULL,
  compare = ".n",
  return_type = c("uids", "ids", "subdf", "df", "interdf"),
  order = "desc(sum)",
  include_zeros = FALSE
)

paired(df = ".", id, compare, idents = 2, uniq = TRUE)

top(
  df = ".",
  id,
  n = 10,
  compare = ".n",
  subset = NULL,
  with_ties = FALSE,
  split_by = NULL,
  return_type = c("uids", "ids", "subdf", "df", "interdf")
)
}
\arguments{
\item{df}{The data frame. Use \code{.} if the function is called in a dplyr pipe.}

\item{group_by}{The column name in the data frame to group the entities.
It could be a quoted string or a bare variable, and defines the groups of entities
for comparison.}

\item{idents}{The values in \code{compare} to compare. It could be either an
an integer or a vector. If it is an integer, the number of values in
\code{compare} must be the same as the integer for the \code{id} to be regarded
as paired. If it is a vector, the values in \code{compare} must be the same
as the values in \code{idents} for the \code{id} to be regarded as paired.}

\item{id}{The column name in \code{df} for the groups.}

\item{subset}{An expression to subset the entities, will be passed to
\code{dplyr::filter()}. Default is \code{TRUE} (no filtering).}

\item{split_by}{A column name (without quotes) in metadata to split the cells.}

\item{compare}{The column name in \code{df} to compare the values for each group.
It could be either a numeric column or \code{.n} to compare the number of
entities in each group. If a column is passed, the values in the column
must be numeric and the same in each group. This won't be checked.}

\item{return_type}{The type of the returned value. Default is \code{uids}.
It could be one of
\itemize{
\item \code{uids}: return the unique ids of the selected entities
\item \code{ids}: return the ids of all entities in the same order as in \code{df}, where the
non-selected ids will be \code{NA}
\item \code{subdf}: return a subset of \code{df} with the selected entities
\item \code{df}: return the original \code{df} with a new logical column \code{.out} to mark
the selected entities
\item \code{interdf}: return the intermediate data frame with the id column, \verb{<compare>},
\code{predicate} and the split_by column if provided.
}}

\item{order}{An expression to order the intermediate data frame before returning
the final result. Default is \code{NULL}. It does not work for \code{subdf} and \code{df}.}

\item{include_zeros}{Whether to include the zero entities in the other group for
\code{more_than} and \code{less_than} comparisons. Default is \code{FALSE}.
By default, the zero entities will be excluded, meaning that the entities must
exist in both groups to be selected.}

\item{uniq}{Whether to return unique ids or not. Default is \code{TRUE}.
If \code{FALSE}, you can mutate the meta data frame with the returned ids.
Non-paired ids will be \code{NA}.}

\item{n}{The number of top entities to return. if \code{n} < 1, it will be
regarded as the percentage of the total number of entities in each group
(after subsetting or each applied).
Specify 0 to return all entities.}

\item{with_ties}{Whether to return all entities with the same size as the
last entity in the top list. Default is \code{FALSE}.}
}
\value{
Depending on the \code{return_type}, the function will return different values.
\itemize{
\item \code{uids}: a vector of unique ids of the selected entities
\item \code{ids}: a vector of ids of all entities in the same order as in \code{df}, where the
non-selected ids will be \code{NA}
\item \code{subdf}: a subset of \code{df} with the selected entities
\item \code{df}: the original \code{df} with a new logical column \code{.selected} to mark the selected
entities
\item \code{interdf}: the intermediate data frame with the id column, \code{ident_1}, \code{ident_2},
\code{predicate}, \code{sum}, and \code{diff} and the split_by column if provided.
}

A vector of paired ids (in \code{id} column)

Depending on the \code{return_type}, the function will return different values.
}
\description{
\itemize{
\item \code{more_than}: Select entities that have more counts in the first group than the second group.
\item \code{less_than}: Select entities that have less counts in the first group than the second group.
\item \code{emerged}: Select entities that have counts in the first group but not in the second group.
\item \code{vanished}: Select entities that have counts in the second group but not in the first group.
\item \code{paired}: Select entities that have the same counts in both groups.
\item \code{top}: Select the top entities from a data frame based on the number of entities in each group.
}
}
\examples{
df <- data.frame(
    id = c("A", "A", "A", "B", "B", "B", "C", "C", "D", "D"),
    group = c("G1", "G1", "G2", "G1", "G2", "G2", "G1", "G2", "G1", "G2"),
    count = rep(1, 10),
    split = c("S1", "S2", "S1", "S1", "S2", "S1", "S1", "S2", "S1", "S2")
)
more_than(df, group_by = group, idents = c("G1", "G2"), id = id, compare = count,
  return_type = "uids")
more_than(df, group_by = group, idents = c("G1", "G2"), id = id, compare = ".n",
  return_type = "uids")
more_than(df, group_by = group, split_by = split, idents = c("G1", "G2"), id = id,
  compare = count, return_type = "ids")
more_than(df, group_by = group, idents = c("G1", "G2"), id = id, compare = count,
  return_type = "subdf")
more_than(df, group_by = group, idents = c("G1", "G2"), id = id, compare = count,
  return_type = "ids")
more_than(df, group_by = group, idents = c("G1", "G2"), id = id, compare = count,
  return_type = "interdf")
more_than(df, group_by = group, idents = c("G1", "G2"), id = id, compare = count,
  return_type = "df")
more_than(df, group_by = group, idents = c("G1", "G2"), id = id,
  return_type = "uids", subset = id \%in\% c("A", "B"))
dplyr::mutate(df, selected = more_than(group_by = group, idents = c("G1", "G2"),
  id = id, compare = count, return_type = "ids"))
less_than(df, group_by = group, idents = c("G1", "G2"), id = id, compare = count,
  return_type = "uids")
emerged(df, group_by = group, idents = c("G1", "G2"), id = id, compare = count,
  return_type = "uids", order = sum)
vanished(df, group_by = group, idents = c("G1", "G2"), id = id, compare = count,
  return_type = "uids")
df <- data.frame(
    id = c("A", "A", "B", "B", "C", "C", "D", "D"),
    compare = c(1, 2, 1, 1, 1, 2, 1, 2)
)
paired(df, id, compare, 2)
paired(df, id, compare, c(1, 2))
paired(df, id, compare, c(1, 2), uniq = FALSE)
df <- data.frame(
    id = c("A", "B", "C", "D", "E", "F", "G", "H"),
    value = c(10, 20, 30, 40, 50, 60, 80, 80)
)
top(df, id, n = 1, compare = value, with_ties = TRUE, return_type = "uids")
top(df, "id", n = 2, compare = "value", return_type = "subdf")
top(df, "id", n = 2, compare = "value", return_type = "df")
top(df, "id", n = 2, compare = "value", return_type = "interdf")
top(df, id, n = 0.25, compare = value, return_type = "uids")
top(df, id, n = 0, compare = value, return_type = "uids")

df <- data.frame(id = c("A", "A", "B", "B", "B", "C", "C", "C", "D", "D", "D", "D"))
top(df, id, n = 2, compare = ".n", return_type = "uids", with_ties = TRUE)
dplyr::mutate(df, selected = top(id = id, n = 2, compare = ".n", return_type = "ids",
  with_ties = TRUE))
}
